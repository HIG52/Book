## 매개변수에 의한 다형성

### 3.1제네릭 함수
매개변수에 의한 다형성 : 타입 매개변수를 통해 다형성을 만드는 기능, 제네릭스(generics)라고도 부름
타입을 구체적으로 정의하지 않고 다양한 타입을 처리할수 있게 해준다.
```
class A{
  static <T> T choose(T v1, T v2) {return ... ? v1 : v2;}
}
String str = A.<String>choose("Korean", "Foreigner");
int num = A.<Integer>choose(1, 2);
```

#### 제네릭 메서드
클래스 안에 정의되는점을 제외하면 제네릭 함수와 같다.

제네릭 함수를 호출할때 타입 인자를 넣어야 하는것 처럼 이역시 호출하려면 타입인자가 필요하다.
```
class Chooser{
  <T> T choose(T v1, T v2) {return ... ? v1 : v2;}
}
Chooser c = new Chooer();
c.<Integer>choose(1, 2);
```

#### 타입 인자 추론
매개 변수에 의한 다형성은 코드 중복을 줄여주는대신 타입인자를 꼬박꼬박 써주어야 한다는 단점이 있음
이를 해소하기 위해 타입 인자 추론이 존재한다.

```
choose<Int>(1, 2);
choose<String>("A", "B");

choose(1, 2);
choose("A", "B");
```

#### 힌들리-밀너 타입 추론
대부분의 언어에서는 제네릭 함수를 사용할때 타입 추론을 해서 타입인자를 찾는데 일부언어는 여기서 더 나아가
제네릭 함수를 정의할 때조차 타입 추론을 한다. 이런방식을 힌들리-밀너 타입추론이라고 부른다.

제네릭 함수를 정의할때 타입추론을 한다는 것이란?
타입 매개변수를 쓰지 않아도 함수가 자동으로 제네릭 함수가 될 수 있다는것이다
```
function choose(v1, v2){
  print(v1); print(v2); print(...);
  Int input = readInt();
  return (input == 0) ? v1 : v2;
}
```
라는 코드를 타입검사기가
```
T choose<T>(T v1, T v2){...}
```
과 같이 바꿔준다.

즉 일반적인 함수처럼 사용하여도 저절로 제네릭 함수가 되는것.

앞선 경우는 "T가 타입 매개변수일 때 함수 안에서 T 타입의 부품은 아무 특별한 능력도 요구되지 않는곳에서만 사용될 수 있다" 라고 하였는데
타입 검사기를 이를 이용하여 그런 매개변수가 하나라도 발견된다면 그함수는 제네릭 함수가 되는것이다.

물론 타입 추론이 대개 그렇듯 편리한 만큼 잘못 사용하게 된다면 이상한 오류를 뱉어서 개발에 차질이 생길수도 있다.

따라서 힌들리-밀너 타입 추론을 제공하는 언어를 사용할땐 일단 매개변수 타입 표시 없이 코드를 작성하다가 이해하기 어려운 오류 메시지가 나오면
함수에 매개변수 타입 표시를 추가해보는것이 좋다.(주요 언어로는 하스켈, 오캐멀이 있다.)










